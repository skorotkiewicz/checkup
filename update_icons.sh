#!/usr/bin/env bash
#
# update_icons.sh — Regenerate src/icons.rs from docs/icons/SVGs/fill/
#
# Download and unzip in docs/icons: https://phosphoricons.com/assets/phosphor-icons.zip (ls docs/icons/SVGs/...)
# Usage: ./update_icons.sh
#
# This script reads Phosphor SVG source files and produces Rust functions
# that accept a size parameter and return inline SVG strings.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SVG_DIR="$SCRIPT_DIR/docs/icons/SVGs/fill"
OUTPUT="$SCRIPT_DIR/src/icons.rs"

# ── Icon mapping: CONST_NAME -> svg-filename (without -fill.svg) ─────────
# Add or remove entries here to change which icons are generated.
declare -A ICONS=(
    [WINDOWS]="windows-logo"
    [LINUX]="linux-logo"
    [APPLE]="apple-logo"
    [PACKAGE]="package"
    [ARCHIVE]="file-archive"
    [COFFEE]="coffee"
    [FILE]="file-text"
    [PAPERCLIP]="paperclip"
    [STAR]="star"
    [DOWNLOAD]="download-simple"
    [CALENDAR]="calendar-blank"
    [NOTE]="note"
)

# ── Doc comments for each constant ───────────────────────────────────────
declare -A DOCS=(
    [WINDOWS]="Windows/Executable icon"
    [LINUX]="Linux icon"
    [APPLE]="Apple/macOS icon"
    [PACKAGE]="Package/AppImage icon"
    [ARCHIVE]="Archive/Compressed file icon"
    [COFFEE]="Coffee/JAR icon"
    [FILE]="File/Source code icon"
    [PAPERCLIP]="Paperclip/Attachment icon"
    [STAR]="Star/Latest icon"
    [DOWNLOAD]="Download icon"
    [CALENDAR]="Calendar/Date icon"
    [NOTE]="Note/Release notes icon"
)

# ── Ordered list (bash associative arrays have no guaranteed order) ───────
ORDERED=(WINDOWS LINUX APPLE PACKAGE ARCHIVE COFFEE FILE PAPERCLIP STAR DOWNLOAD CALENDAR NOTE)

# ── Helper: transform a raw Phosphor SVG into a template with {size} placeholder ─
transform_svg() {
    local file="$1"
    local content
    content="$(cat "$file")"

    # 1. Add width="{size}" height="{size}" to the <svg> tag (format! placeholders)
    content="$(echo "$content" | sed 's/<svg /<svg width="{size}" height="{size}" /')"

    # 2. Remove the placeholder <rect width="256" height="256" fill="none"/>
    content="$(echo "$content" | sed 's/<rect[^/]*\/>//g')"

    # 3. Add fill="currentColor" to every <path> that doesn't already have a fill
    #    Phosphor fill icons don't set fill on <path>, so we inject it.
    content="$(echo "$content" | sed 's/<path /<path fill="currentColor" /g')"

    # 4. Collapse to a single line and trim whitespace
    content="$(echo "$content" | tr '\n' ' ' | sed 's/  */ /g' | sed 's/^ *//;s/ *$//')"

    echo "$content"
}

# ── Validate SVG directory exists ────────────────────────────────────────
if [[ ! -d "$SVG_DIR" ]]; then
    echo "ERROR: SVG directory not found: $SVG_DIR" >&2
    exit 1
fi

# ── Generate src/icons.rs ────────────────────────────────────────────────
echo "Generating $OUTPUT from $SVG_DIR ..."

{
    cat <<'HEADER'
//! SVG icons for the application
//! Icons from Phosphor Icons (https://phosphoricons.com/)
//!
//! AUTO-GENERATED by update_icons.sh — do not edit by hand.
//! To update, run: ./update_icons.sh

#![allow(non_snake_case)]

HEADER

    for name in "${ORDERED[@]}"; do
        svg_base="${ICONS[$name]}"
        svg_file="$SVG_DIR/${svg_base}-fill.svg"

        if [[ ! -f "$svg_file" ]]; then
            echo "WARNING: Missing SVG file: $svg_file — skipping $name" >&2
            continue
        fi

        svg_content="$(transform_svg "$svg_file")"
        doc="${DOCS[$name]}"

        echo "/// $doc"
        echo "pub fn ${name}(size: u32) -> String {"
        echo "    format!("
        echo "        r#\"${svg_content}\"#,"
        echo "        size = size"
        echo "    )"
        echo "}"
        echo
    done

    # ── get_file_icon() function ─────────────────────────────────────────
    cat <<'FUNC'
/// Returns the appropriate icon SVG based on file extension
pub fn get_file_icon(filename: &str, size: u32) -> String {
    if filename.ends_with(".exe") || filename.ends_with(".msi") {
        WINDOWS(size)
    } else if filename.ends_with(".deb") || filename.ends_with(".rpm") {
        LINUX(size)
    } else if filename.ends_with(".dmg")
        || filename.contains("darwin")
        || filename.contains("macos")
    {
        APPLE(size)
    } else if filename.ends_with(".AppImage") {
        PACKAGE(size)
    } else if filename.ends_with(".tar.gz")
        || filename.ends_with(".tgz")
        || filename.ends_with(".tar.xz")
        || filename.ends_with(".tar.bz2")
    {
        ARCHIVE(size)
    } else if filename.ends_with(".zip") {
        ARCHIVE(size)
    } else if filename.ends_with(".jar") {
        COFFEE(size)
    } else if filename.contains("source") || filename.contains("src") {
        FILE(size)
    } else {
        PAPERCLIP(size)
    }
}
FUNC
} > "$OUTPUT"

echo "Done! Updated $(grep -c 'pub fn' "$OUTPUT") icon functions in $OUTPUT"
